import os
import sys
import subprocess
import SCons

from SCons.Subst import quote_spaces
from pathlib import Path
from classes.buildInfoClass import loadBuildInfo

buildInfo = loadBuildInfo()

EnsureSConsVersion(4, 3, 0)

def LinkDir(src, trg):
    VariantDir(trg, src, duplicate = 1)
    return trg

linkedDir = LinkDir(buildInfo.pathInfo.sourceCodePath, buildInfo.pathInfo.outputPath)

def print_cmd_line(s, target, source, env):
    """
    Override default SCons print routine.
    """
    # for linking, more than one source in specified
    # for compiling, exactly one source per target is specified.
    if len(source) > 1:
        print("\nLinking '{}' ... ".format(str(target[0])))
    else:
        print("Compiling '{}' ...".format(str(source[0])))
    # Regular output in python is buffered. Since the actual printing
    # is done by pop through subprocess, every print statement needs
    # to be enforced on the spot to allow smooth printing.
    sys.stdout.flush()

class ourSpawn:
    """
    Spawn class required to overcome problem with to long command lines see:
    https://github.com/SCons/scons/wiki/LongCmdLinesOnWin32
    """
    def ourspawn(self, sh, escape, cmd, args, env):
        newargs = ' '.join(args[1:])
        cmdline = cmd + " " + newargs
        startupinfo = subprocess.STARTUPINFO()
        startupinfo.dwFlags |= subprocess.STARTF_USESHOWWINDOW
        proc = subprocess.Popen(cmdline, stdin=subprocess.PIPE, stdout=subprocess.PIPE,
                                stderr=subprocess.PIPE, startupinfo=startupinfo, shell=False, env=env)
        data, err = proc.communicate()
        rv = proc.wait()
        if rv:
            print("=====")
            print(err)
            print("=====")
        return rv

def SetupSpawn(env):
    """
        Generates class element required to overcome problem with to long command lines see:
        https://github.com/SCons/scons/wiki/LongCmdLinesOnWin32
    """
    if sys.platform == 'win32':
        buf = ourSpawn()
        buf.ourenv = env
        env['SPAWN'] = buf.ourspawn

# Place build results in outputPath directory instead of the source code directory
# VariantDir(buildInfo.pathInfo.outputPath, buildInfo.pathInfo.sourceCodePath, duplicate=1)

# pipes the outside PATH variable into scons
env = Environment(
    # pipes all output to the print_cmd_line function in order to use the custom logger
    # instead of simple print output
    PRINT_CMD_LINE_FUNC=print_cmd_line,
    # sCons usually hides the user path variables in order to guarantee reproducable builds. Since bob already
    # takes care of this and we want to inject custom pathes, the user path variable is piped to scons.
    ENV = os.environ,
    # C flags. The current implmeenteation merges includes, defines and actual flags in this variable
    CCFLAGS = buildInfo.toolchain.compilerFlags,
    ASFLAGS = buildInfo.toolchain.assemblerFlags,
    LINKFLAGS = buildInfo.toolchain.linkerFlags,
    OBJSUFFIX = ".o",
    PROGSUFFIX = buildInfo.runInfo.elfSuffix,
    CCCOM = buildInfo.toolchain.CCompilerCommand,
    # 'CXXCOM' buildInfo.toolchain.CPlusPlusompilerCommand,
    ASCOM = buildInfo.toolchain.assemblerCommand,
    LINKCOM = buildInfo.toolchain.linkerCommand,
    CC = buildInfo.softwareInfo.getCompiler(buildInfo.runInfo.architecture),
    # 'CXX'= buildInfo.softwareInfo.getCPlusPlusCompiler(buildInfo.runInfo.architecture),
    AS = buildInfo.softwareInfo.getAssembler(buildInfo.runInfo.architecture),
    LINK = buildInfo.softwareInfo.getLinker(buildInfo.runInfo.architecture),
)

SetupSpawn(env)

moduleFlags = buildInfo.toolchain.generaleModuleCompilerFlags
if buildInfo.toolchain.generalModuleAssemblerFlags:
    moduleFlags.update(buildInfo.toolchain.generalModuleAssemblerFlags)
if buildInfo.toolchain.generaleModuleLinkerFlags:
    moduleFlags.update(buildInfo.toolchain.generaleModuleLinkerFlags)

sourceFiles = buildInfo.pathInfo.sourceCodeFiles
regularSourceFiles = [sourcFile for sourcFile in sourceFiles if sourcFile not in moduleFlags]
#objects =  Object(regularSourceFiles, CCFLAGS = '')
# objects = env.Object(regularSourceFiles)
# for sourceFile in modulesFlagsFiles:
#     tmpEnv = env.close(CPPFLAGS = '')
#     tmpEnv[Flags] = moduleFlags
#     objects += Object('sourceFile', CCFLAGS = '')


# CCFLAGS f�r C++ setzen. Diese werden auch f�r einfach f�r C verwendet, daher erst hier setzen in einem eigenen
# Environment

linkedSourceList = [linkedDir + "\\" + str(Path("06_MCAL/Adc") / Path(regularSourceFile).stem) for regularSourceFile in regularSourceFiles]
for source in regularSourceFiles:
#    _ = LinkDir(Path(source).parent, linkedDir + "\\" + str(Path(source).parent))
    _ = LinkDir(Path(source).parent, str(Path(linkedDir) / Path(source).stem))

objectList = env.Object(linkedSourceList)

env.Program(buildInfo.pathInfo.elfFile, objectList)
# env.Program(buildInfo.pathInfo.elfFile, regularSourceFiles)


